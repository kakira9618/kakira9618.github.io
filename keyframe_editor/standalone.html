<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Keyframe Editor</title>
  <style>
    :root { --bg:#0b0f17; --panel:#121a2a; --text:#e6edf6; --muted:#9fb0c3; --accent:#7aa2ff; --danger:#ff6b6b; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 18px; border-bottom:1px solid rgba(255,255,255,.08); }
    header h1 { margin:0; font-size:16px; letter-spacing:.4px; }
    main { display: flex; flex-direction: column; gap: 16px; padding: 16px 18px 28px; width: 100%; max-width: none; margin: 0 auto; }
    .split-row { display: grid; grid-template-columns: minmax(0, 8fr) minmax(240px, 2fr); gap: 14px; align-items: start; width: 100%; }
    @media (max-width: 960px) { .split-row { grid-template-columns: 1fr; } }
    .card { background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > * { flex: 0 0 auto; margin: 0; }
    label { font-size:12px; color:var(--muted); }
    input[type="file"] { color:var(--muted); }
    button, select, input[type="text"] {
      background:#0f1523; border:1px solid rgba(255,255,255,.12); color:var(--text);
      border-radius:10px; padding:10px 12px; font-size:13px;
    }
    button { cursor:pointer; }
    button:hover { background:#1a2030; }
    button.primary { background: rgba(122,162,255,.18); border-color: rgba(122,162,255,.35); }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .danger { border-color: rgba(255,107,107,.45); background: rgba(255,107,107,.12); }
    .small { padding: 8px 10px; border-radius:10px; font-size:12px; }
    .right { justify-content:flex-end; }
    .badge { font-size: 12px; padding: 3px 8px; border: 1px solid rgba(255,255,255,.12); border-radius: 999px; background:rgba(255,255,255,.08); color:var(--muted); font-family: ui-monospace, monospace; min-width: 5em; display: inline-block; text-align: center; }
    .time-digi-wrap { position: relative; display: inline-block; min-width:110px; }
    .time-digi {
      font-family: "SFMono-Regular","Roboto Mono","Fira Code","Ubuntu Mono",ui-monospace,monospace;
      font-size: 22px;
      letter-spacing: 0.08em;
      padding: 10px 14px;
      border-radius: 12px;
      background: linear-gradient(145deg, #0a111e, #0d182a);
      border: 1px solid rgba(255, 209, 102, 0.35);
      color: #ffd166;
      text-shadow: 0 0 8px rgba(255,209,102,0.6), 0 0 2px rgba(255,255,255,0.2);
      box-shadow: inset 0 0 8px rgba(255,209,102,0.08), 0 8px 24px rgba(0,0,0,0.35);
      min-width: 110px;
      text-align: center;
      cursor: pointer;
    }
    .time-digi-edit {
      all: unset;
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      box-sizing:border-box;
      font-family: "SFMono-Regular","Roboto Mono","Fira Code","Ubuntu Mono",ui-monospace,monospace;
      font-size: 22px !important;
      line-height: 1.1;
      letter-spacing: 0.08em;
      padding: 10px 14px;
      border-radius: 12px;
      background: linear-gradient(145deg, #0a111e, #0d182a);
      border: 1px solid rgba(255, 209, 102, 0.5);
      color: #ffd166;
      text-shadow: 0 0 8px rgba(255,209,102,0.6), 0 0 2px rgba(255,255,255,0.2);
      box-shadow: inset 0 0 8px rgba(255,209,102,0.12), 0 8px 24px rgba(0,0,0,0.35);
      text-align: center;
      caret-color: #ffd166;
    }
    .time-digi-edit::selection { background: rgba(255,209,102,0.25); color:#ffd166; }
    .wavewrap { display: grid; gap: 10px; margin-top:12px; }
    .wavebox { border: 1px solid rgba(255,255,255,.06); border-radius: 12px; overflow: hidden; padding: 10px; background:#0a0f1b; }
    #overview-container { height: 70px; }
    #zoomview-container { height: 140px; touch-action: none; }
    #spectrum-container { position: relative; height: 190px; overflow: hidden; background:#080c16; }
    #spectrum-canvas { position:absolute; inset:0; width: 100%; height: 100%; display: block; background:#050911; }
    .spec-playhead { position:absolute; top:0; left:0; bottom:0; width:1px; background:#ffd166; box-shadow:0 0 4px rgba(255,209,102,.45); pointer-events:none; opacity:0.95; display:none; }
    .spec-status { position:absolute; left:12px; bottom:10px; font-size:11px; color:var(--muted); background:rgba(0,0,0,.35); padding:4px 8px; border-radius:8px; pointer-events:none; }
    .muted { color: var(--muted); font-size: 12px; }
    /* Peaks point visibility (Zoom view) */
    #zoomview-container .peaks-point {
      width: 14px !important;
      height: 14px !important;
      margin-left: -7px !important;
      margin-top: -7px !important;
      border: 2px solid #0b0f17 !important;
      border-radius: 50% !important;
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.4),
        0 0 12px rgba(255,209,102,0.65),
        0 0 22px rgba(0,0,0,0.55);
      opacity: 0.95 !important;
    }
    #zoomview-container .peaks-point:hover {
      transform: scale(1.08);
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.55),
        0 0 16px rgba(255,209,102,0.8),
        0 0 28px rgba(0,0,0,0.7);
    }
    #zoomview-container .peaks-point-label {
      background: rgba(0,0,0,0.7) !important;
      color: #f5f7ff !important;
      font-size: 11px !important;
      padding: 3px 6px !important;
      border-radius: 8px !important;
      border: 1px solid rgba(255,255,255,0.25) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
      transform: translateY(-16px);
    }
    .list { border-top: 1px solid rgba(255,255,255,.08); margin-top: 10px; padding-top: 10px; }
    .kf { display:grid; grid-template-columns: 60px 90px 200px 1fr auto; gap: 8px; align-items:center; padding: 8px; border: 1px solid rgba(255,255,255,.08); border-radius: 10px; margin: 8px 0; }
    .kf time { font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }
    .kf input[type="text"] { width: 100%; border: 1px solid rgba(255,255,255,.12); border-radius: 10px; padding: 7px 9px; font-size: 12px; background:#0a0f1b; color:var(--text); }
    .kf select { width: 100%; }
    .krow { display:flex; gap:8px; align-items:center; }
    .krow input[type="text"] { width:100%; }
    textarea {
      width:100%; min-height:260px; resize:vertical; padding:12px; border-radius:12px;
      background:#0a0f1b; border:1px solid rgba(255,255,255,.10); color:var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; line-height:1.45;
    }

    /* Zoom slider styles */
    .zoom-control { display: flex; flex-direction: column; gap: 4px; min-width: 160px; align-items: center; }
    .zoom-slider-wrapper { position: relative; height: 24px; display: flex; align-items: center; }
    input[type="range"].zoom-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 2px;
      background: rgba(255,255,255,.2);
      border-radius: 2px;
      outline: none;
      padding: 0;
      margin: 0;
    }
    input[type="range"].zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--bg);
      box-shadow: 0 0 0 1px rgba(122,162,255,.3);
    }
    input[type="range"].zoom-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--bg);
      box-shadow: 0 0 0 1px rgba(122,162,255,.3);
    }
    input[type="range"].zoom-slider:disabled {
      opacity: .4;
      cursor: not-allowed;
    }
    input[type="range"].zoom-slider:disabled::-webkit-slider-thumb {
      cursor: not-allowed;
    }
    input[type="range"].zoom-slider:disabled::-moz-range-thumb {
      cursor: not-allowed;
    }
    .zoom-label { font-size: 11px; color: var(--muted); text-align: center; }
    .zoom-label, .kf time {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 3px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,209,102,0.35);
      background: linear-gradient(145deg, rgba(255,209,102,0.06), rgba(255,209,102,0.02));
      color: #ffd166;
      cursor: pointer;
      font-variant-numeric: tabular-nums;
      box-shadow: 0 3px 10px rgba(0,0,0,0.18);
    }

    /* Drop zone */
    .dropzone {
      border: 1px dashed rgba(255,255,255,0.25);
      border-radius: 12px;
      padding: 12px 14px;
      background: radial-gradient(circle at 20% 20%, rgba(122,162,255,.08), rgba(10,15,27,0.4));
      color: var(--muted);
      transition: border-color .15s ease, background .15s ease, color .15s ease;
    }
    .dropzone.hover {
      border-color: rgba(255,209,102,0.8);
      background: radial-gradient(circle at 20% 20%, rgba(255,209,102,.10), rgba(10,15,27,0.55));
      color: #ffd166;
    }
    .file-btn {
      display:inline-block;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.25);
      background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      font-size:13px;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      box-shadow: 0 6px 18px rgba(0,0,0,0.28);
    }
    .file-btn:hover {
      transform: translateY(-1px);
      border-color: rgba(255,209,102,0.7);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    .ctrl-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      font-size: 14px;
      line-height: 1.2;
      cursor: pointer;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      min-width: 48px;
      max-width: 48px;
      text-align: center;
    }
    .ctrl-btn.primary {
      border-color: rgba(122,162,255,0.35);
      background: rgba(122,162,255,0.16);
    }
    .ctrl-btn:disabled { opacity: .6; cursor: not-allowed; }
    .ctrl-btn:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      border-color: rgba(255,209,102,0.6);
    }
  </style>
</head>
<body>
  <header style="display:flex; flex-direction:column; gap:8px; padding-bottom:4px;">
    <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
        <h1 style="margin-right:6px;">Keyframe Editor v1.0.0</h1>
        <a href="https://x.com/kakira9618" target="_blank" rel="noopener" style="color:var(--muted); font-size:13px; text-decoration:none;">
          by @kakira9618
        </a>
      </div>
    <div class="muted" style="font-size:12px; text-align:right;">
      操作:
      <kbd style="font-family: ui-monospace, monospace; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:2px 6px; border-radius:6px;">Space</kbd>
      再生/停止、
      <kbd style="font-family: ui-monospace, monospace; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:2px 6px; border-radius:6px;">h</kbd>/<kbd style="font-family: ui-monospace, monospace; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:2px 6px; border-radius:6px;">l</kbd>
      コマ送り、
      <kbd style="font-family: ui-monospace, monospace; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:2px 6px; border-radius:6px;">K</kbd>
      キーフレーム追加
    </div>
    </div>
    <div style="display:flex; align-items:flex-start; gap:10px; flex-wrap:wrap;">
      <div id="fileDrop" class="dropzone">
        <label style="display:block; margin-bottom:6px;">音源選択（mp3 / wav / ogg / flac / m4a）</label>
        <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
          <label for="file" class="file-btn">音声を選択</label>
          <input id="file" type="file" accept="audio/*" style="display:none;" />
          <span id="fileNameLabel" class="muted" style="font-size:12px;">ファイル未選択</span>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="row" style="align-items:center; gap:12px; flex-wrap:wrap;">
        <div style="flex:1; min-width:120px;"></div>

        <div style="flex:0 0 auto; display:flex; flex-direction:column; align-items:center; gap:6px; width:200px;">
          <div id="timeDisplayWrap" class="time-digi-wrap">
            <div id="timeDisplay" class="time-digi">--:--.---</div>
          </div>
          <div class="row" style="gap:8px; flex-wrap:nowrap; white-space:nowrap; align-items:center; padding:6px 0 4px;">
            <button id="stepBack" class="ctrl-btn" disabled title="コマ送り戻す (h)">⏮︎</button>
            <button id="play" class="ctrl-btn primary" disabled title="再生/停止 (Space)">▶︎</button>
            <button id="stepFwd" class="ctrl-btn" disabled title="コマ送り進む (l)">⏭︎</button>
            <span style="height:26px; width:1px; background: rgba(255,255,255,0.18); margin:0 6px; display:inline-block;"></span>
            <button id="addKf" class="ctrl-btn primary" disabled title="キーフレーム追加 (K)">✚</button>
          </div>
        </div>

        <div class="row" style="flex:1; justify-content:flex-end; align-items:center; gap:12px; min-width:260px;">
          <div class="zoom-control">
            <label>再生速度</label>
            <div class="zoom-slider-wrapper">
              <input id="rate" type="range" class="zoom-slider" min="0" max="200" step="1" value="100" disabled />
            </div>
            <div id="rateLabel" class="zoom-label">1x</div>
          </div>

          <div class="zoom-control">
            <label>波形ズーム</label>
          <div class="zoom-slider-wrapper">
            <input id="zoom" type="range" class="zoom-slider" min="0" max="200" step="1" value="100" disabled />
          </div>
          <div id="zoomLabel" class="zoom-label">1x</div>
        </div>
        </div>
      </div>


      <div class="wavewrap" style="margin-top:12px;">
        <div class="wavebox">
          <div class="muted">Overview</div>
          <div id="overview-container"></div>
        </div>
        <div class="wavebox">
          <div class="muted">Zoom view</div>
          <div id="zoomview-container"></div>
        </div>
        <div class="wavebox">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <div class="muted">Spectrogram</div>
            <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
              <label class="row" style="gap:6px; font-size:12px; color:var(--muted);">
                <input id="enableSpectrogram" type="checkbox" checked />
                スペクトログラムを計算する
              </label>
              <label class="row" style="gap:6px; font-size:12px; color:var(--muted);">
                <input id="useWebGPU" type="checkbox" />
                WebGPUを使う
              </label>
            </div>
          </div>
          <div id="spectrum-container">
            <canvas id="spectrum-canvas"></canvas>
            <div id="spectrum-status" class="spec-status">ファイル未選択</div>
            <div id="spectrum-playhead" class="spec-playhead" aria-hidden="true"></div>
          </div>
        </div>
      </div>

      <audio id="audio" preload="auto" crossorigin="anonymous"></audio>
    </section>

    <div class="split-row">
      <section class="card">
        <div class="list">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <div>
              <strong style="font-size:13px;">キーフレーム一覧</strong>
            </div>
            <div class="row" style="gap:8px; align-items:center;">
              <label class="muted" style="font-size:11px;">フィルタ</label>
              <select id="labelFilter" class="small" style="padding:6px 8px; font-size:12px; min-width:120px;">
                <option value="">(すべて)</option>
              </select>
            </div>
          </div>
          <div id="kfList"></div>
        </div>
      </section>

      <aside class="card">
        <div class="row" style="justify-content:space-between;">
          <strong style="font-size:13px;">Keyframes JSON</strong>
          <button id="copy" disabled>コピー</button>
        </div>
        <textarea id="json" spellcheck="false"></textarea>
      </aside>
    </div>
  </main>

  <!-- Peaks.js standalone UMD (dist/peaks.js is stand-alone and includes dependencies) -->
  <script src="https://unpkg.com/peaks.js/dist/peaks.js"></script>

  <script>
    const el = (id) => document.getElementById(id);

    const fileInput = el('file');
    const dropZone = el('fileDrop');
    const audio = el('audio');
    const overviewContainer = el('overview-container');
    const zoomviewContainer = el('zoomview-container');
    const spectrumCanvas = el('spectrum-canvas');
    const spectrumContainer = el('spectrum-container');
    const spectrumStatus = el('spectrum-status');
    const specPlayhead = el('spectrum-playhead');
    const chkWebGPU = el('useWebGPU');

    const btnPlay = el('play');
    const btnStepBack = el('stepBack');
    const btnStepFwd = el('stepFwd');
    const selRate = el('rate');
    const elRateLabel = el('rateLabel');
    const elZoom = el('zoom');
    const elZoomLabel = el('zoomLabel');
    const timeBadge = el('timeDisplay');

    const btnAddKf = el('addKf');
    const kfList = el('kfList');
    const labelFilter = el('labelFilter');

    const jsonArea = el('json');
    const btnCopy = el('copy');
    const timeWrap = el('timeDisplayWrap');
    const fileNameLabel = el('fileNameLabel');
    const chkEnableSpec = el('enableSpectrogram');
    let rememberedWebGpu = true;
    let timeEditInput = null;
    let isTimeEditing = false;
    let timeEditBaseTime = 0;

    let peaksInstance = null;
    let objectUrl = null;
    let audioSampleRate = null;
    let audioBufferSrc = null;
    let isScrubbingOverview = false;
    let isScrubbingZoomview = false;
    let isScrubbingSpectrum = false;
    let specSyncRaf = null;
    let audioContext = null;
    let spectrogram = null;           // { data, frames, bins, sampleRate, hopSize, duration, totalDuration, sliceStart, sliceDuration }
    let spectrogramRequestId = 0;
    let hiResSpec = null;             // { data, frames, bins, sampleRate, hopSize, duration, viewStart, viewDuration }
    let hiResRequestId = 0;
    let hiResPending = false;
    let lastHiResRequestedAt = 0;
    const webgpuSupported = typeof navigator !== 'undefined' && !!navigator.gpu;
    let webgpuDevice = null;
    let webgpuQueue = null;
    let webgpuPipeline = null;
    let preferWebGPU = webgpuSupported;
    let stepPreviewTimer = null;
    let isStepPreview = false;
    let specViewStart = 0;
    let specViewDuration = 0;
    let specScrubRaf = null;

    // keyframes: { id, time, label, comment, pointId }
    let keyframes = [];
    let allLabels = []; // ユニークなラベル一覧
    let kfSeq = 1;
    let lastEditedLabel = '';
    let sortField = 'id'; // 'time' | 'label' | 'id'
    let sortDir = 1; // 1 = asc, -1 = desc
    let filterLabel = '';
    let isUpdatingJsonArea = false;
    let jsonApplyTimer = null;
    const JSON_APPLY_DEBOUNCE_MS = 450;

    const FRAME_SEC = 1 / 60;

    // ラベル名から一貫した色を生成（HSLベース）
    function getLabelColor(label) {
      if (!label) return '#888888';
      let hash = 0;
      for (let i = 0; i < label.length; i++) {
        hash = label.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = Math.abs(hash % 360);
      return `hsl(${hue}, 70%, 60%)`;
    }

    // 全ラベル一覧を更新
    function refreshLabelFilterOptions() {
      if (!labelFilter) return;
      const prev = filterLabel || labelFilter.value || '';
      labelFilter.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = '';
      optAll.textContent = '(すべて)';
      labelFilter.appendChild(optAll);
      const optNone = document.createElement('option');
      optNone.value = '__NONE__';
      optNone.textContent = '(なし)';
      labelFilter.appendChild(optNone);
      for (const label of allLabels) {
        const opt = document.createElement('option');
        opt.value = label;
        opt.textContent = label;
        labelFilter.appendChild(opt);
      }
      if (prev === '__NONE__') {
        labelFilter.value = '__NONE__';
        filterLabel = '__NONE__';
      } else if (prev && allLabels.includes(prev)) {
        labelFilter.value = prev;
        filterLabel = prev;
      } else {
        labelFilter.value = '';
        filterLabel = '';
      }
    }

    function updateAllLabels() {
      const labelSet = new Set();
      for (const kf of keyframes) {
        if (kf.label) labelSet.add(kf.label);
      }
      allLabels = Array.from(labelSet).sort();
      refreshLabelFilterOptions();
    }

    function formatTime(sec) {
      if (!Number.isFinite(sec)) return '--:--.---';
      const m = Math.floor(sec / 60);
      const s = sec - m * 60;
      const ss = Math.floor(s).toString().padStart(2, '0');
      const ms = Math.floor((s - Math.floor(s)) * 1000).toString().padStart(3, '0');
      return `${m.toString().padStart(2,'0')}:${ss}.${ms}`;
    }

    function isAudioFile(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith('audio/')) return true;
      return /\.(mp3|wav|ogg|flac|m4a)$/i.test(file.name || '');
    }

    function setUiEnabled(enabled) {
      for (const node of [btnPlay, btnStepBack, btnStepFwd, selRate, elZoom, btnAddKf, btnCopy]) {
        node.disabled = !enabled;
      }
    }

    async function loadFile(file) {
      if (!file || !isAudioFile(file)) {
        alert('対応している音声ファイルを選択してください (mp3 / wav / ogg など)');
        return;
      }
      if (keyframes.length > 0) {
        const ok = window.confirm('キーフレームが存在します。変更が破棄されますが、別の音源を読み込みますか？');
        if (!ok) {
          try { if (fileInput) fileInput.value = ''; } catch (_) {}
          return;
        }
      }
      setUiEnabled(false);
      try {
        await initWithFile(file);
        if (fileNameLabel) fileNameLabel.textContent = file.name || '';
      } catch (e) {
        console.error(e);
        alert('初期化に失敗しました（コンソールを確認してください）');
        if (fileNameLabel) fileNameLabel.textContent = '';
        setUiEnabled(false);
      }
    }

    function updateTimeBadge() {
      if (isTimeEditing) return;
      timeBadge.textContent = formatTime(audio.currentTime);
    }

    function normalizeNumberLikeText(str) {
      if (!str) return '';
      let out = str;
      // 全角数字・記号を半角に
      out = out.replace(/[０-９]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xFEE0));
      out = out.replace(/[：]/g, ':');
      out = out.replace(/[．。]/g, '.');
      out = out.replace(/[＋﹢]/g, '+');
      out = out.replace(/[－ーｰ―‐−﹣]/g, '-');
      out = out.replace(/[，、]/g, ',');
      return out;
    }

    function parseTimeInput(str, currentTime, duration) {
      if (!str) return null;
      const s = normalizeNumberLikeText(str).trim();
      if (!s) return null;

      const clampTime = (t) => clamp(t, 0, Number.isFinite(duration) ? duration : Infinity);

      const parseAbsolute = (text) => {
        const parts = text.split(':');
        if (parts.length === 1) {
          const v = parseFloat(parts[0]);
          return Number.isFinite(v) ? v : null;
        }
        let total = 0;
        for (let i = 0; i < parts.length; i++) {
          const v = parseFloat(parts[i]);
          if (!Number.isFinite(v)) return null;
          total = total * 60 + v;
        }
        return total;
      };

      const parseDelta = (text) => {
        const sign = text.startsWith('-') ? -1 : 1;
        const body = text.slice(1);
        const absVal = parseAbsolute(body);
        if (absVal === null) return null;
        return clampTime(currentTime + sign * absVal);
      };

      // Relative (+/-)
      if (s.startsWith('+') || s.startsWith('-')) {
        return parseDelta(s);
      }

      // Absolute
      const abs = parseAbsolute(s);
      if (abs === null) return null;
      return clampTime(abs);
    }

    function exitTimeEdit(applyValue) {
      if (!isTimeEditing) return;
      const input = timeEditInput;
      if (input && applyValue) {
        const base = Number.isFinite(timeEditBaseTime) ? timeEditBaseTime : audio.currentTime;
        const target = parseTimeInput(input.value, base, audio.duration);
        if (Number.isFinite(target)) {
          const wasPlaying = !audio.paused;
          audio.currentTime = target;
          updateSpecPlayhead();
          if (wasPlaying) audio.play().catch(() => {});
        } else {
          alert('時刻の形式が認識できません');
        }
      }
      if (input && input.parentNode) input.parentNode.removeChild(input);
      timeEditInput = null;
      isTimeEditing = false;
      timeEditBaseTime = 0;
      timeBadge.style.visibility = 'visible';
      updateTimeBadge();
    }

    function startInlineTimeEdit() {
      if (!Number.isFinite(audio.duration) || isTimeEditing) return;
      isTimeEditing = true;
      timeEditBaseTime = audio.currentTime;
      const currentText = formatTime(timeEditBaseTime);
      const rect = timeBadge.getBoundingClientRect();
      const parent = timeBadge.parentNode;
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'time-digi-edit';
      input.value = currentText;
      timeEditInput = input;
      timeBadge.style.visibility = 'hidden';
      parent.appendChild(input);

      const confirm = () => exitTimeEdit(true);
      const cancel = () => exitTimeEdit(false);

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); confirm(); }
        if (e.key === 'Escape') { e.preventDefault(); cancel(); }
      });
      input.addEventListener('blur', confirm);

      setTimeout(() => {
        input.focus();
        input.setSelectionRange(0, input.value.length);
      }, 0);
    }

    function clamp(v, lo, hi) { return Math.min(hi, Math.max(lo, v)); }

    // Generic drag-to-nudge helper. While dragging horizontally, calls applyValue with updated value.
    function attachDragNudge(el, {
      getValue,
      applyValue,
      stepPerPx = 0.01,
      min = -Infinity,
      max = Infinity,
      compute // optional (dx, startVal) => newVal
    }) {
      if (!el || typeof getValue !== 'function' || typeof applyValue !== 'function') return;
      let dragging = false;
      let moved = false;
      let startX = 0;
      let startVal = 0;

      const onPointerDown = (e) => {
        startX = e.clientX;
        startVal = getValue();
        dragging = true;
        moved = false;
        el.setPointerCapture?.(e.pointerId);
        e.preventDefault();
      };

      const update = (dx, isFinal) => {
        const minVal = typeof min === 'function' ? min() : min;
        const maxVal = typeof max === 'function' ? max() : max;
        const base = typeof compute === 'function'
          ? compute(dx, startVal)
          : startVal + dx * stepPerPx;
        const next = clamp(base, minVal, maxVal);
        applyValue(next, !!isFinal);
      };

      const onPointerMove = (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        if (!moved && Math.abs(dx) > 2) moved = true;
        update(dx, false);
        e.preventDefault();
      };

      const onPointerUp = (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        const wasMoved = moved || Math.abs(dx) > 2;
        dragging = false;
        el.releasePointerCapture?.(e.pointerId);
        if (wasMoved) {
          update(dx, true);
          // prevent the subsequent click from triggering inline edit
          el.dataset.skipClick = '1';
          setTimeout(() => { el.dataset.skipClick = '0'; }, 0);
          e.preventDefault();
          e.stopPropagation();
        }
      };

      el.addEventListener('pointerdown', onPointerDown);
      el.addEventListener('pointermove', onPointerMove);
      el.addEventListener('pointerup', onPointerUp);
      el.addEventListener('pointercancel', onPointerUp);
      el.addEventListener('pointerleave', onPointerUp);
    }

    function getZoomWindowDuration() {
      if (!audioSampleRate) return 0;
      const width = zoomviewContainer.clientWidth || 1;
      const spp = currentSamplesPerPixel();
      return (spp / audioSampleRate) * width;
    }

    function getZoomWindowStart(viewDuration) {
      if (!peaksInstance) return 0;
      const view = peaksInstance.views && peaksInstance.views.getView ? peaksInstance.views.getView('zoomview') : null;
      if (view && typeof view.getStartTime === 'function') {
        const st = view.getStartTime();
        if (Number.isFinite(st)) return st;
      }
      const duration = audio.duration || 0;
      const center = audio.currentTime || 0;
      const maxStart = Math.max(0, duration - viewDuration);
      return clamp(center - viewDuration / 2, 0, maxStart);
    }

    function seekOverviewToClientX(clientX) {
      if (!Number.isFinite(audio.duration)) return;
      const rect = overviewContainer.getBoundingClientRect();
      const ratio = clamp((clientX - rect.left) / rect.width, 0, 1);
      const target = ratio * audio.duration;
      audio.currentTime = target;
      // force zoom view window to center on target
      const viewDuration = getZoomWindowDuration();
      const newStart = clamp(target - viewDuration / 2, 0, Math.max(0, (audio.duration || 0) - viewDuration));
      setZoomWindowStart(newStart);
      updateTimeBadge();
      updateSpecPlayhead();
    }


    function setZoomWindowStart(startTime) {
      if (!peaksInstance) return;
      const viewDuration = getZoomWindowDuration();
      const duration = audio.duration || 0;
      const targetStart = clamp(startTime, 0, Math.max(0, duration - viewDuration));
      const view = peaksInstance.views && peaksInstance.views.getView ? peaksInstance.views.getView('zoomview') : null;
      try {
        if (view && typeof view.setStartTime === 'function') {
          view.setStartTime(targetStart);
        } else if (peaksInstance.zoom && typeof peaksInstance.zoom.setZoom === 'function') {
          // setZoom(zoomIndex, optionalStartTime) がサポートされている場合に備える
          const factor = currentSliderFactor(elZoom, zoomMap);
          applyZoom(factor, targetStart);
        }
      } catch (e) {
        console.warn('Failed to set zoom window start:', e);
      }
      const specView = getSpecView();
      drawSpectrogram(specView.viewStart, specView.viewDuration);
      updateSpecPlayhead();
      return targetStart;
    }

    function seekInZoomview(evt) {
      if (!Number.isFinite(audio.duration)) return;
      const rect = zoomviewContainer.getBoundingClientRect();
      const ratio = clamp((evt.clientX - rect.left) / rect.width, 0, 1);
      const viewDuration = getZoomWindowDuration();
      const start = getZoomWindowStart(viewDuration);
      audio.currentTime = clamp(start + ratio * viewDuration, 0, audio.duration);
      updateTimeBadge();
      updateSpecPlayhead();
    }

    function seekInSpectrum(evt) {
      if (!Number.isFinite(audio.duration)) return;
      const rect = spectrumContainer.getBoundingClientRect();
      const { viewStart, viewDuration } = getSpecView();
      const ppsCss = currentPixelsPerSecond() || 0;
      const contentWidth = Math.max(1, Math.min(rect.width, viewDuration * ppsCss));
      const relX = clamp(evt.clientX - rect.left, 0, contentWidth);
      const ratio = relX / contentWidth;
      audio.currentTime = clamp(viewStart + ratio * viewDuration, 0, audio.duration);
      updateTimeBadge();
      updateSpecPlayhead();
      maybeRedrawSpecOnViewChange();
    }

    function bindScrubHandlers() {
      // Overview: ドラッグでズーム窓をパン（シークしない）
      let ovStartX = 0;
      let ovStartWindow = 0;
      let ovMoved = false;
      overviewContainer.addEventListener('pointerdown', (e) => {
        if (!Number.isFinite(audio.duration)) return;
        isScrubbingOverview = true;
        ovStartX = e.clientX;
        ovStartWindow = getZoomWindowStart(getZoomWindowDuration());
        ovMoved = false;
        overviewContainer.setPointerCapture?.(e.pointerId);
        e.preventDefault();
      });
      overviewContainer.addEventListener('pointermove', (e) => {
        if (!isScrubbingOverview) return;
        const rect = overviewContainer.getBoundingClientRect();
        const pxToSec = (audio.duration || 0) / rect.width;
        const deltaSec = (e.clientX - ovStartX) * pxToSec;
        setZoomWindowStart(ovStartWindow + deltaSec);
        if (Math.abs(e.clientX - ovStartX) > 3) ovMoved = true;
        e.preventDefault();
      });
      const stopOverview = (e) => {
        if (!isScrubbingOverview) return;
        isScrubbingOverview = false;
        overviewContainer.releasePointerCapture?.(e.pointerId);
        if (!ovMoved) {
          seekOverviewToClientX(e.clientX);
        }
      };
      overviewContainer.addEventListener('pointerup', stopOverview);
      overviewContainer.addEventListener('pointerleave', stopOverview);
      overviewContainer.addEventListener('pointercancel', stopOverview);

      // Zoom view: ドラッグでシーク（リアルタイムで再生位置更新）
      zoomviewContainer.addEventListener('pointerdown', (e) => {
        if (!Number.isFinite(audio.duration)) return;
        isScrubbingZoomview = true;
        startScrubSpecSync();
        seekInZoomview(e);
        zoomviewContainer.setPointerCapture?.(e.pointerId);
        e.preventDefault();
      });
      zoomviewContainer.addEventListener('pointermove', (e) => {
        if (isScrubbingZoomview) {
          seekInZoomview(e);
          maybeRedrawSpecOnViewChange();
          e.preventDefault();
        }
      });
      const stopZoom = (e) => {
        isScrubbingZoomview = false;
        zoomviewContainer.releasePointerCapture?.(e.pointerId);
        stopScrubSpecSync();
      };
      zoomviewContainer.addEventListener('pointerup', stopZoom);
      zoomviewContainer.addEventListener('pointerleave', stopZoom);
      zoomviewContainer.addEventListener('pointercancel', stopZoom);

      // Zoom view: ホイールで倍率変更（カーソル位置を基準に拡大縮小）
      zoomviewContainer.addEventListener('wheel', (e) => {
        if (!peaksInstance || !Number.isFinite(audio.duration) || !audioSampleRate) return;
        e.preventDefault();
        const rect = zoomviewContainer.getBoundingClientRect();
        const ratio = clamp((e.clientX - rect.left) / rect.width, 0, 1);

        const viewDurationBefore = getZoomWindowDuration();
        const startBefore = getZoomWindowStart(viewDurationBefore);
        const targetTime = clamp(startBefore + ratio * viewDurationBefore, 0, audio.duration);

        const currentFactor = currentSliderFactor(elZoom, zoomMap);
        const scale = Math.exp(-e.deltaY * 0.0015); // 感度
        let nextFactor = clamp(currentFactor * scale, zoomMap.min, zoomMap.max);
        let snapped = false;
        if (Math.abs(nextFactor - 1) <= SNAP_RANGE) {
          nextFactor = 1;
          snapped = true;
        }

        const sppAfter = Math.round(factorToSamplesPerPixel(nextFactor));
        const width = rect.width || 1;
        const viewDurationAfter = (sppAfter / audioSampleRate) * width;
        const maxStart = Math.max(0, audio.duration - viewDurationAfter);
        const nextStart = clamp(targetTime - ratio * viewDurationAfter, 0, maxStart);

        const sliderVal = sliderFromFactor(nextFactor, zoomMap);
        elZoom.value = String(sliderVal);
        setFactorLabel(elZoomLabel, nextFactor, snapped);
        applyZoom(nextFactor, nextStart);
      }, { passive: false });

      // Overview: ホイールで水平スクロール
      overviewContainer.addEventListener('wheel', (e) => {
        if (!Number.isFinite(audio.duration)) return;
        const rect = overviewContainer.getBoundingClientRect();
        const pxToSec = (audio.duration || 0) / rect.width;
        const deltaPx = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
        const viewDuration = getZoomWindowDuration();
        const start = getZoomWindowStart(viewDuration);
        setZoomWindowStart(start + deltaPx * pxToSec);
        e.preventDefault();
      }, { passive: false });

      // Spectrum: click/drag to seek
      spectrumContainer.addEventListener('pointerdown', (e) => {
        if (!Number.isFinite(audio.duration)) return;
        isScrubbingSpectrum = true;
        seekInSpectrum(e);
        spectrumContainer.setPointerCapture?.(e.pointerId);
        e.preventDefault();
      });
      spectrumContainer.addEventListener('pointermove', (e) => {
        if (isScrubbingSpectrum) {
          seekInSpectrum(e);
          e.preventDefault();
        }
      });
      const stopSpec = (e) => {
        isScrubbingSpectrum = false;
        spectrumContainer.releasePointerCapture?.(e.pointerId);
      };
      spectrumContainer.addEventListener('pointerup', stopSpec);
      spectrumContainer.addEventListener('pointerleave', stopSpec);
      spectrumContainer.addEventListener('pointercancel', stopSpec);

      // Spectrum: wheel zoom (same as zoomview)
      spectrumContainer.addEventListener('wheel', (e) => {
        if (!peaksInstance || !Number.isFinite(audio.duration) || !audioSampleRate) return;
        e.preventDefault();
        const rect = spectrumContainer.getBoundingClientRect();
        const ratio = clamp((e.clientX - rect.left) / rect.width, 0, 1);

        const viewDurationBefore = getZoomWindowDuration();
        const startBefore = getZoomWindowStart(viewDurationBefore);
        const targetTime = clamp(startBefore + ratio * viewDurationBefore, 0, audio.duration);

        const currentFactor = currentSliderFactor(elZoom, zoomMap);
        const scale = Math.exp(-e.deltaY * 0.0015);
        let nextFactor = clamp(currentFactor * scale, zoomMap.min, zoomMap.max);
        let snapped = false;
        if (Math.abs(nextFactor - 1) <= SNAP_RANGE) {
          nextFactor = 1;
          snapped = true;
        }

        const sppAfter = Math.round(factorToSamplesPerPixel(nextFactor));
        const width = rect.width || 1;
        const viewDurationAfter = (sppAfter / audioSampleRate) * width;
        const maxStart = Math.max(0, audio.duration - viewDurationAfter);
        const nextStart = clamp(targetTime - ratio * viewDurationAfter, 0, maxStart);

        const sliderVal = sliderFromFactor(nextFactor, zoomMap);
        elZoom.value = String(sliderVal);
        setFactorLabel(elZoomLabel, nextFactor, snapped);
        applyZoom(nextFactor, nextStart);
      }, { passive: false });
    }

    function updateJson() {
      if (!jsonArea) return;
      const payload = {
        keyframes: keyframes
          .slice()
          .sort((a,b) => a.time - b.time)
          .map(({time, label, comment, seq}) => {
            const base = { time, label: label || "", comment: comment || "" };
            base.id = seq ?? null;
            return base;
          })
      };
      isUpdatingJsonArea = true;
      jsonArea.value = JSON.stringify(payload, null, 2);
      clearJsonError();
      isUpdatingJsonArea = false;
    }

    function clearJsonError() {
      if (!jsonArea) return;
      jsonArea.style.borderColor = '';
      jsonArea.style.boxShadow = '';
      jsonArea.title = '';
    }

    function markJsonError(message) {
      if (!jsonArea) return;
      jsonArea.style.borderColor = 'rgba(255,107,107,0.7)';
      jsonArea.style.boxShadow = '0 0 0 1px rgba(255,107,107,0.4)';
      jsonArea.title = message;
    }

    function normalizeImportedKeyframes(data) {
      const root = Array.isArray(data) ? { keyframes: data } : data;
      if (!root || typeof root !== 'object') {
        throw new Error('オブジェクトまたは配列の JSON を指定してください');
      }
      if (!Array.isArray(root.keyframes)) {
        throw new Error('\"keyframes\" 配列が見つかりません');
      }

      const parsed = [];
      let maxSeq = 0;

      for (let i = 0; i < root.keyframes.length; i++) {
        const raw = root.keyframes[i];
        if (!raw || typeof raw !== 'object') {
          throw new Error(`keyframes[${i}] がオブジェクトではありません`);
        }
        const time = Number(raw.time);
        if (!Number.isFinite(time) || time < 0) {
          throw new Error(`keyframes[${i}].time は 0 以上の数値で指定してください`);
        }
        const label = raw.label != null ? String(raw.label) : '';
        const comment = raw.comment != null ? String(raw.comment) : '';
        let seq = Number(raw.id);
        if (!Number.isFinite(seq) || seq <= 0) seq = i + 1;
        maxSeq = Math.max(maxSeq, seq);
        parsed.push({
          id: `kf-${seq}`,
          seq,
          time,
          label,
          comment,
          pointId: null
        });
      }

      return { items: parsed, nextSeq: maxSeq + 1 };
    }

    function clearPeaksPoints() {
      if (!peaksInstance || !peaksInstance.points) return;
      try {
        if (typeof peaksInstance.points.removeAll === 'function') {
          peaksInstance.points.removeAll();
          return;
        }
      } catch (e) {
        console.warn('points.removeAll failed:', e);
      }
      try {
        const pts = typeof peaksInstance.points.getPoints === 'function'
          ? peaksInstance.points.getPoints()
          : [];
        for (const p of pts) {
          if (!p || !p.id) continue;
          try { peaksInstance.points.removeById(p.id); } catch (_) {}
        }
      } catch (e) {
        console.warn('points.getPoints/removeById failed:', e);
      }
    }

    function rebuildPeaksPoints() {
      if (!peaksInstance || !peaksInstance.points) return;
      clearPeaksPoints();
      for (const kf of keyframes) {
        try {
          const p = peaksInstance.points.add({
            time: kf.time,
            labelText: kf.id,
            editable: false,
            color: kf.label ? getLabelColor(kf.label) : '#888888'
          });
          kf.pointId = p && p.id ? p.id : null;
        } catch (e) {
          console.warn('points.add failed:', e);
        }
      }
    }

    function refreshPeaksViews() {
      if (!peaksInstance || !peaksInstance.views || typeof peaksInstance.views.getView !== 'function') return;
      try { peaksInstance.views.getView('zoomview')?.render?.(); } catch (_) {}
      try { peaksInstance.views.getView('overview')?.render?.(); } catch (_) {}
    }

    function updateLastEditedLabelFromKeyframes() {
      lastEditedLabel = '';
      for (let i = keyframes.length - 1; i >= 0; i--) {
        const lbl = keyframes[i].label;
        if (lbl) { lastEditedLabel = lbl; break; }
      }
    }

    function applyJsonToState() {
      if (!jsonArea) return;
      let parsed;
      try {
        parsed = JSON.parse(jsonArea.value);
      } catch (e) {
        markJsonError('JSON の構文エラー: ' + e.message);
        return;
      }

      let normalized;
      try {
        normalized = normalizeImportedKeyframes(parsed);
      } catch (e) {
        markJsonError(e.message);
        return;
      }

      keyframes = normalized.items;
      kfSeq = normalized.nextSeq;
      updateLastEditedLabelFromKeyframes();
      updateAllLabels();
      renderKeyframeList();
      rebuildPeaksPoints();
      updatePointColors();
      updateJson();
      clearJsonError();
    }

    function renderKeyframeList() {
      kfList.innerHTML = '';
      const base = (() => {
        if (filterLabel === '__NONE__') {
          return keyframes.filter(k => !k.label);
        }
        if (filterLabel) {
          return keyframes.filter(k => (k.label || '') === filterLabel);
        }
        return keyframes;
      })();
      const sorted = base.slice().sort((a,b) => {
        let cmp = 0;
        if (sortField === 'label') {
          const la = (a.label || '').toLowerCase();
          const lb = (b.label || '').toLowerCase();
          if (la !== lb) cmp = la < lb ? -1 : 1;
          else cmp = a.time - b.time;
        } else if (sortField === 'id') {
          cmp = (a.seq ?? 0) - (b.seq ?? 0);
        } else {
          cmp = a.time - b.time;
        }
        return cmp * sortDir;
      });

      // header row
      const head = document.createElement('div');
      head.className = 'kf';
      head.style.fontWeight = '600';
      head.style.cursor = 'pointer';
      head.style.userSelect = 'none';
      head.style.background = 'rgba(255,255,255,0.03)';

      const arrow = (field) => {
        if (sortField !== field) return ' ';
        return sortDir === 1 ? '▲' : '▼';
      };

      const hId = document.createElement('div');
      hId.textContent = `ID ${arrow('id')}`;
      hId.style.fontSize = '12px';
      hId.style.color = sortField === 'id' ? '#ffd166' : 'var(--muted)';
      hId.addEventListener('click', () => {
        if (sortField === 'id') {
          sortDir = -sortDir;
        } else {
          sortField = 'id';
          sortDir = 1;
        }
        renderKeyframeList();
      });

      const hTime = document.createElement('div');
      hTime.textContent = `時間 ${arrow('time')}`;
      hTime.style.fontSize = '12px';
      hTime.style.color = sortField === 'time' ? '#ffd166' : 'var(--muted)';
      hTime.addEventListener('click', () => {
        if (sortField === 'time') {
          sortDir = -sortDir;
        } else {
          sortField = 'time';
          sortDir = 1;
        }
        renderKeyframeList();
      });

      const hLabel = document.createElement('div');
      hLabel.textContent = `ラベル ${arrow('label')}`;
      hLabel.style.fontSize = '12px';
      hLabel.style.color = sortField === 'label' ? '#ffd166' : 'var(--muted)';
      hLabel.addEventListener('click', () => {
        if (sortField === 'label') {
          sortDir = -sortDir;
        } else {
          sortField = 'label';
          sortDir = 1;
        }
        renderKeyframeList();
      });

      const hComment = document.createElement('div');
      hComment.textContent = 'コメント';
      hComment.style.fontSize = '12px';
      hComment.style.color = 'var(--muted)';

      const hAction = document.createElement('div');
      hAction.textContent = '操作';
      hAction.style.fontSize = '12px';
      hAction.style.color = 'var(--muted)';
      hAction.style.textAlign = 'right';

      head.appendChild(hId);
      head.appendChild(hTime);
      head.appendChild(hLabel);
      head.appendChild(hComment);
      head.appendChild(hAction);
      kfList.appendChild(head);

      if (sorted.length === 0) {
        const p = document.createElement('p');
        p.className = 'muted';
        p.textContent = 'まだキーフレームがありません。';
        kfList.appendChild(p);
        return;
      }

      for (const kf of sorted) {
        const row = document.createElement('div');
        row.className = 'kf';

        const idCell = document.createElement('div');
        idCell.textContent = kf.seq ?? '';
        idCell.style.fontVariantNumeric = 'tabular-nums';
        idCell.style.fontSize = '12px';

        const t = document.createElement('time');
        t.textContent = formatTime(kf.time);
        t.style.cursor = 'text';
        t.title = 'クリックで時間を編集（例: 12.3 / 01:02.500 / +1 / -0.25）';

        const startKfTimeEdit = () => {
          if (!Number.isFinite(audio.duration)) return;
          const input = document.createElement('input');
          input.type = 'text';
          input.value = formatTime(kf.time);
          input.style.all = 'unset';
          input.style.width = '90%';
          input.style.padding = '6px 8px';
          input.style.borderRadius = '8px';
          input.style.border = '1px solid rgba(255,255,255,0.25)';
          input.style.background = '#0a0f1b';
          input.style.color = 'var(--text)';
          input.style.fontSize = '12px';
          input.style.fontFamily = 'ui-monospace, SFMono-Regular, monospace';
          input.style.textAlign = 'center';

          const parent = t.parentNode;
          const container = document.createElement('div');
          container.style.display = 'flex';
          container.style.alignItems = 'center';
          container.appendChild(input);
          if (parent) parent.replaceChild(container, t);

          let finished = false;
          const finish = (apply) => {
            if (finished) return;
            finished = true;
            if (apply) {
              const parsed = parseTimeInput(input.value, kf.time, audio.duration);
              if (Number.isFinite(parsed)) {
                kf.time = parsed;
                if (kf.pointId && peaksInstance) {
                  try { peaksInstance.points.update({ id: kf.pointId, time: parsed }); } catch (_) {}
                }
                renderKeyframeList();
                updateJson();
                return;
              }
            }
            if (parent) parent.replaceChild(t, container);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); finish(true); }
            if (e.key === 'Escape') { e.preventDefault(); finish(false); }
          });
          input.addEventListener('blur', () => finish(true));
          setTimeout(() => {
            input.focus();
            input.setSelectionRange(0, input.value.length);
          }, 0);
        };

        t.addEventListener('click', (e) => {
          e.stopPropagation();
          if (t.dataset.skipClick === '1') { t.dataset.skipClick = '0'; return; }
          startKfTimeEdit();
        });

        attachDragNudge(t, {
          getValue: () => kf.time,
          applyValue: (v, isFinal) => {
            const dur = Number.isFinite(audio.duration) ? audio.duration : Infinity;
            const next = clamp(v, 0, dur);
            kf.time = next;
            rebuildPeaksPoints();
            t.textContent = formatTime(next);
            refreshPeaksViews();
            updateSpecPlayhead();
            if (isFinal) {
              renderKeyframeList();
              updateJson();
            }
          },
          min: 0,
          max: () => Number.isFinite(audio.duration) ? audio.duration : Infinity,
          stepPerPx: 0.01
        });

        // Label column
        const labelWrap = document.createElement('div');
        labelWrap.className = 'krow';
        labelWrap.style.gap = '6px';
        labelWrap.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Color indicator
        const colorDot = document.createElement('span');
        colorDot.style.display = 'inline-block';
        colorDot.style.width = '10px';
        colorDot.style.height = '10px';
        colorDot.style.borderRadius = '50%';
        colorDot.style.backgroundColor = kf.label ? getLabelColor(kf.label) : '#888';
        colorDot.style.flexShrink = '0';

        const labelSelect = document.createElement('select');
        labelSelect.style.flex = '1';
        labelSelect.style.minWidth = '0';

        // 空のオプション
        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '（なし）';
        labelSelect.appendChild(emptyOpt);

        // 既存のラベル
        for (const label of allLabels) {
          const opt = document.createElement('option');
          opt.value = label;
          opt.textContent = label;
          labelSelect.appendChild(opt);
        }

        // 新規作成
        const newOpt = document.createElement('option');
        newOpt.value = '__NEW__';
        newOpt.textContent = '+ 新規作成';
        labelSelect.appendChild(newOpt);

        labelSelect.value = kf.label || '';

        // クリックイベントの伝播を防止
        labelSelect.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        labelSelect.addEventListener('change', (e) => {
          e.stopPropagation();
          if (labelSelect.value === '__NEW__') {
            const newLabel = prompt('新しいラベル名を入力してください:');
            if (newLabel && newLabel.trim()) {
              kf.label = newLabel.trim();
              lastEditedLabel = kf.label;
              updateAllLabels();
              updatePointColors();
              renderKeyframeList();
              updateJson();
            } else {
              labelSelect.value = kf.label || '';
            }
          } else {
            kf.label = labelSelect.value;
            lastEditedLabel = kf.label || '';
            colorDot.style.backgroundColor = kf.label ? getLabelColor(kf.label) : '#888';
            updatePointColors();
            updateJson();
          }
        });

        labelWrap.appendChild(colorDot);
        labelWrap.appendChild(labelSelect);

        // Comment column
        const commentWrap = document.createElement('div');
        commentWrap.className = 'krow';
        commentWrap.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        const inp = document.createElement('input');
        inp.type = 'text';
        inp.placeholder = 'コメント（例: サビ開始 / カット点）';
        inp.value = kf.comment ?? '';
        inp.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        inp.addEventListener('input', () => {
          kf.comment = inp.value;
          updateJson();
        });
        commentWrap.appendChild(inp);

        // Actions column
        const actionsWrap = document.createElement('div');
        actionsWrap.className = 'krow';
        actionsWrap.style.gap = '6px';
        actionsWrap.style.justifyContent = 'flex-end';

        const btnJump = document.createElement('button');
        btnJump.className = 'small';
        btnJump.textContent = 'ジャンプ';
        btnJump.addEventListener('click', (e) => {
          e.stopPropagation();
          audio.currentTime = kf.time;
          audio.pause(); // ジャンプ時は止めて精密編集しやすく
          updateTimeBadge();
          updateSpecPlayhead();
        });

        const btnSetNow = document.createElement('button');
        btnSetNow.className = 'small';
        btnSetNow.textContent = '現在位置を設定';
        btnSetNow.addEventListener('click', (e) => {
          e.stopPropagation();
          const tnow = audio.currentTime;
          kf.time = tnow;
          if (kf.pointId && peaksInstance) {
            try { peaksInstance.points.update({ id: kf.pointId, time: tnow }); } catch (_) {}
          }
          renderKeyframeList();
          updateJson();
        });

        const btnDel = document.createElement('button');
        btnDel.className = 'small danger';
        btnDel.textContent = '削除';
        btnDel.addEventListener('click', (e) => {
          e.stopPropagation();
          removeKeyframe(kf.id);
        });

        actionsWrap.appendChild(btnJump);
        actionsWrap.appendChild(btnSetNow);
        actionsWrap.appendChild(btnDel);

        row.appendChild(idCell);
        row.appendChild(t);
        row.appendChild(labelWrap);
        row.appendChild(commentWrap);
        row.appendChild(actionsWrap);

        kfList.appendChild(row);
      }
    }

    function removeKeyframe(id) {
      const kf = keyframes.find(k => k.id === id);
      if (kf && kf.pointId && peaksInstance) {
        try {
          peaksInstance.points.removeById(kf.pointId);
        } catch (e) {
          console.warn('Failed to remove point:', e);
        }
      }
      keyframes = keyframes.filter(k => k.id !== id);
      updateAllLabels();
      renderKeyframeList();
      updateJson();
    }

    function updatePointColors() {
      if (!peaksInstance) return;
      try {
        for (const kf of keyframes) {
          if (kf.pointId) {
            const point = peaksInstance.points.getPoint(kf.pointId);
            if (point) {
              const color = kf.label ? getLabelColor(kf.label) : '#888888';
              point.update({ color });
            }
          }
        }
      } catch (e) {
        console.warn('Failed to update point colors:', e);
      }
    }

    function destroyPeaks() {
      if (peaksInstance) {
        try { peaksInstance.destroy(); } catch (_) {}
        peaksInstance = null;
      }
      overviewContainer.innerHTML = '';
      zoomviewContainer.innerHTML = '';
      audioSampleRate = null;
      audioBufferSrc = null;
      hiResSpec = null;
      hiResRequestId++;
      teardownSpectrum();
    }

    function teardownSpectrum() {
      spectrogramRequestId++;
      spectrogram = null;
      clearSpectrumCanvas();
      const off = chkEnableSpec && !chkEnableSpec.checked;
      setSpectrumStatus(off ? 'スペクトログラム計算スキップ' : 'ファイル未選択');
      updateSpecPlayhead(true);
    }

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    function resizeSpectrumCanvas() {
      if (!spectrumCanvas) return;
      const dpr = window.devicePixelRatio || 1;
      const { width, height } = spectrumContainer.getBoundingClientRect();
      const targetW = Math.max(1, Math.floor(width * dpr));
      const targetH = Math.max(1, Math.floor(height * dpr));
      if (spectrumCanvas.width !== targetW) spectrumCanvas.width = targetW;
      if (spectrumCanvas.height !== targetH) spectrumCanvas.height = targetH;
    }

    function clearSpectrumCanvas() {
      if (!spectrumCanvas) return;
      resizeSpectrumCanvas();
      const ctx = spectrumCanvas.getContext('2d');
      if (ctx) ctx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
    }

    function setSpectrumStatus(text) {
      if (!spectrumStatus) return;
      spectrumStatus.textContent = text || '';
      spectrumStatus.style.display = text ? 'block' : 'none';
    }

    function createFFT(size) {
      if (size & (size - 1)) throw new Error('FFT size must be power of 2');
      const levels = Math.log2(size);
      const rev = new Uint32Array(size);
      for (let i = 0; i < size; i++) {
        let x = i, y = 0;
        for (let j = 0; j < levels; j++) {
          y = (y << 1) | (x & 1);
          x >>= 1;
        }
        rev[i] = y;
      }
      const sinTable = new Float32Array(size / 2);
      const cosTable = new Float32Array(size / 2);
      for (let i = 0; i < size / 2; i++) {
        const ang = -2 * Math.PI * i / size;
        sinTable[i] = Math.sin(ang);
        cosTable[i] = Math.cos(ang);
      }
      return {
        transform(re, im) {
          const n = size;
          for (let i = 0; i < n; i++) {
            const j = rev[i];
            if (j > i) {
              const tr = re[i]; re[i] = re[j]; re[j] = tr;
              const ti = im[i]; im[i] = im[j]; im[j] = ti;
            }
          }
          for (let len = 2; len <= n; len <<= 1) {
            const half = len >> 1;
            const step = size / len;
            for (let i = 0; i < n; i += len) {
              for (let j = 0; j < half; j++) {
                const k = j * step;
                const cos = cosTable[k];
                const sin = sinTable[k];
                const tre = re[i + j + half] * cos - im[i + j + half] * sin;
                const tim = re[i + j + half] * sin + im[i + j + half] * cos;
                re[i + j + half] = re[i + j] - tre;
                im[i + j + half] = im[i + j] - tim;
                re[i + j] += tre;
                im[i + j] += tim;
              }
            }
          }
          return { re, im };
        }
      };
    }

    function buildHeatLut() {
      const stops = [
        { t: 0.0, c: [5, 8, 17] },
        { t: 0.25, c: [32, 54, 120] },
        { t: 0.5, c: [69, 137, 205] },
        { t: 0.7, c: [255, 209, 102] },
        { t: 0.85, c: [255, 128, 96] },
        { t: 1.0, c: [255, 255, 255] }
      ];
      const lut = new Array(256);
      for (let i = 0; i < 256; i++) {
        const t = i / 255;
        let a = stops[0], b = stops[stops.length - 1];
        for (let j = 0; j < stops.length - 1; j++) {
          if (t >= stops[j].t && t <= stops[j + 1].t) {
            a = stops[j]; b = stops[j + 1]; break;
          }
        }
        const localT = (t - a.t) / Math.max(1e-6, (b.t - a.t));
        const mix = (x, y) => Math.round(x + (y - x) * localT);
        lut[i] = [mix(a.c[0], b.c[0]), mix(a.c[1], b.c[1]), mix(a.c[2], b.c[2])];
      }
      return lut;
    }

    const HEAT_LUT = buildHeatLut();

    function getSpecView() {
      const duration = Number.isFinite(audio?.duration) ? audio.duration : (spectrogram?.duration || 0);

      // Prefer Peaks zoom view actual window (accounts for internal clamping/rounding)
      if (peaksInstance && peaksInstance.views && typeof peaksInstance.views.getView === 'function') {
        const view = peaksInstance.views.getView('zoomview');
        if (view) {
          const start = typeof view.getStartTime === 'function' ? view.getStartTime() : null;
          const end = typeof view.getEndTime === 'function' ? view.getEndTime() : null;
          if (Number.isFinite(start) && Number.isFinite(end) && end > start) {
            const vs = clamp(start, 0, Math.max(0, duration));
            const vd = clamp(end - start, 0, duration);
            return { viewStart: vs, viewDuration: vd };
          }
        }
      }

      // Fallback to manual computation
      let viewDuration = getZoomWindowDuration();
      if (!Number.isFinite(viewDuration) || viewDuration <= 0) viewDuration = duration;
      viewDuration = Math.min(viewDuration, duration);
      let viewStart = peaksInstance ? getZoomWindowStart(viewDuration) : 0;
      viewStart = clamp(viewStart, 0, Math.max(0, duration - viewDuration));
      return { viewStart, viewDuration };
    }

    function currentPixelsPerSecond() {
      const spp = currentSamplesPerPixel();
      if (!audioSampleRate || !spp) return null;
      return audioSampleRate / spp; // CSS px per second (Peaks uses CSS px for coords)
    }

    function nearestPow2(n) {
      let p = 1;
      while (p < n) p <<= 1;
      return p;
    }

    function floorPow2(n) {
      let p = 1;
      while ((p << 1) <= n) p <<= 1;
      return p;
    }

    function shouldUseHiRes(ppsCss) {
      if (!spectrogram || !ppsCss) return false;
      // Zoomed-in if samplesPerPixel is below the 1x baseline
      const zoomedIn = currentSamplesPerPixel() < BASE_SPP_1X;
      if (!zoomedIn) return false;
      const baseStepSec = spectrogram.hopSize / spectrogram.sampleRate;
      // If base time step is larger than ~0.8 pixel, use hi-res
      return baseStepSec > (1 / ppsCss) * 0.8;
    }

    function maybeRequestHiRes(viewStart, viewDuration, ppsCss) {
      if (!shouldUseHiRes(ppsCss)) return;
      if (!audioBufferSrc) return;
      const duration = Number.isFinite(audio?.duration) ? audio.duration : (spectrogram?.totalDuration || 0);
      if (!(duration > 0)) return;
      const hopTarget = Math.max(32, Math.min(4096, floorPow2(audioSampleRate / ppsCss)));
      if (hiResMatches(viewStart, viewDuration, hopTarget)) return;
      if (hiResPending) return;
      const now = performance.now ? performance.now() : Date.now();
      if (now - lastHiResRequestedAt < 120) return; // throttle

      // expand window a bit to avoid frequent rebuild during scroll
      const pad = Math.min(viewDuration * 0.25, duration * 0.25);
      const start = clamp(viewStart - pad, 0, Math.max(0, duration - viewDuration));
      const dur = Math.min(viewDuration * 1.5, duration);
      buildHiResSpectrogram(start, dur, ppsCss);
    }

    function hiResMatches(viewStart, viewDuration, hopSize) {
      if (!hiResSpec) return false;
      const eps = 1 / 60; // allow small drift
      return Math.abs(hiResSpec.viewStart - viewStart) < eps &&
             Math.abs(hiResSpec.viewDuration - viewDuration) < eps &&
             hiResSpec.hopSize === hopSize;
    }

    // WebGPU helpers ---------------------------------------------------------
    async function ensureWebGPU() {
      if (!webgpuSupported || !preferWebGPU) return null;
      if (webgpuDevice) return webgpuDevice;
      try {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return null;
        webgpuDevice = await adapter.requestDevice();
        webgpuQueue = webgpuDevice.queue;
        return webgpuDevice;
      } catch (e) {
        console.warn('WebGPU init failed, fallback to CPU', e);
        return null;
      }
    }

    function getFftShader() {
      return /* wgsl */`
      struct InBuf { data: array<f32>, };
      struct OutBuf { data: array<f32>, };
      @group(0) @binding(0) var<storage, read>  inBuf : InBuf;
      @group(0) @binding(1) var<storage, read_write> outBuf : OutBuf;

      const FFT_SIZE : u32 = 1024u;
      const BINS : u32 = 512u;
      const PI2 : f32 = 6.283185307179586;
      const LOGN : u32 = 10u; // log2(1024)

      var<workgroup> realBuf : array<f32, FFT_SIZE>;
      var<workgroup> imagBuf : array<f32, FFT_SIZE>;

      fn bitrev(v : u32, bits : u32) -> u32 {
        var r : u32 = 0u;
        var i : u32 = 0u;
        loop {
          if (i >= bits) { break; }
          r = (r << 1u) | ((v >> i) & 1u);
          i = i + 1u;
        }
        return r;
      }

      @compute @workgroup_size(256)
      fn main(@builtin(workgroup_id) wg_id : vec3<u32>,
              @builtin(local_invocation_id) lid : vec3<u32>) {
        let frame = wg_id.x;
        let base = frame * FFT_SIZE;

        // load to shared
        var i = lid.x;
        loop {
          if (i >= FFT_SIZE) { break; }
          realBuf[i] = inBuf.data[base + i];
          imagBuf[i] = 0.0;
          i = i + 256u;
        }
        workgroupBarrier();

        // bit-reversal permutation
        i = lid.x;
        loop {
          if (i >= FFT_SIZE) { break; }
          let j = bitrev(i, LOGN);
          if (j > i) {
            let tr = realBuf[i];
            let ti = imagBuf[i];
            realBuf[i] = realBuf[j];
            imagBuf[i] = imagBuf[j];
            realBuf[j] = tr;
            imagBuf[j] = ti;
          }
          i = i + 256u;
        }
        workgroupBarrier();

        // iterative radix-2 Cooley-Tukey
        var m : u32 = 2u;
        loop {
          if (m > FFT_SIZE) { break; }
          let half = m >> 1u;
          let angStep = PI2 / f32(m);
          var k = lid.x;
          loop {
            if (k >= FFT_SIZE) { break; }
            let j = k & (m - 1u);
            if (j < half) {
              let tw = f32(j);
              let ang = -angStep * tw;
              let cs = cos(ang);
              let sn = sin(ang);
              let block = k - j;
              let idx = block + j;
              let idx2 = idx + half;
              let tre = realBuf[idx2] * cs - imagBuf[idx2] * sn;
              let tim = realBuf[idx2] * sn + imagBuf[idx2] * cs;
              realBuf[idx2] = realBuf[idx] - tre;
              imagBuf[idx2] = imagBuf[idx] - tim;
              realBuf[idx] = realBuf[idx] + tre;
              imagBuf[idx] = imagBuf[idx] + tim;
            }
            k = k + 256u;
          }
          workgroupBarrier();
          m = m << 1u;
        }

        // write magnitudes
        var b = lid.x;
        loop {
          if (b >= BINS) { break; }
          let re = realBuf[b];
          let im = imagBuf[b];
          outBuf.data[frame * BINS + b] = sqrt(re * re + im * im);
          b = b + 256u;
        }
      }`;
    }

    async function ensureFftPipeline(device) {
      if (webgpuPipeline) return webgpuPipeline;
      const module = device.createShaderModule({ code: getFftShader() });
      webgpuPipeline = device.createComputePipeline({
        layout: 'auto',
        compute: { module, entryPoint: 'main' }
      });
      return webgpuPipeline;
    }

    async function computeSpectrogramWebGPU({ audioBuffer, start = 0, duration = audioBuffer.duration, hopSize, fftSize = 1024 }) {
      const device = await ensureWebGPU();
      if (!device || fftSize !== 1024) return null; // shader is fixed-size

      const sampleRate = audioBuffer.sampleRate;
      const channelCount = audioBuffer.numberOfChannels;
      const startSample = Math.max(0, Math.floor(start * sampleRate));
      const endSample = Math.min(audioBuffer.length, Math.ceil((start + duration) * sampleRate));
      const segmentLen = Math.max(0, endSample - startSample);
      const bins = fftSize / 2;
      const frames = Math.max(1, Math.floor((segmentLen - fftSize) / hopSize) + 1);
      if (frames <= 0) return null;

      const hann = buildHann(fftSize);
      const frameData = new Float32Array(frames * fftSize);
      for (let frame = 0; frame < frames; frame++) {
        const offset = frame * hopSize;
        for (let i = 0; i < fftSize; i++) {
          const idx = startSample + offset + i;
          let sample = 0;
          if (idx < endSample) {
            let s = 0;
            for (let ch = 0; ch < channelCount; ch++) {
              s += audioBuffer.getChannelData(ch)[idx];
            }
            sample = s / channelCount;
          }
          frameData[frame * fftSize + i] = sample * hann[i];
        }
      }

      const inputSize = frameData.byteLength;
      const outputSize = frames * bins * 4;

      const inputBuffer = device.createBuffer({
        size: inputSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
      });
      const outputBuffer = device.createBuffer({
        size: outputSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
      });
      const readbackBuffer = device.createBuffer({
        size: outputSize,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });

      webgpuQueue.writeBuffer(inputBuffer, 0, frameData.buffer, frameData.byteOffset, frameData.byteLength);
      const pipeline = await ensureFftPipeline(device);
      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: inputBuffer } },
          { binding: 1, resource: { buffer: outputBuffer } }
        ]
      });

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginComputePass();
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.dispatchWorkgroups(frames);
      pass.end();
      encoder.copyBufferToBuffer(outputBuffer, 0, readbackBuffer, 0, outputSize);
      device.queue.submit([encoder.finish()]);

      await readbackBuffer.mapAsync(GPUMapMode.READ);
      const mapped = readbackBuffer.getMappedRange();
      const outData = new Float32Array(mapped.slice(0));
      readbackBuffer.unmap();

      // Normalize to 0..1 using peak magnitude
      let peak = 1e-9;
      for (let i = 0; i < outData.length; i++) {
        if (outData[i] > peak) peak = outData[i];
      }
      const minDb = -85;
      const spanDb = -minDb;
      for (let i = 0; i < outData.length; i++) {
        const db = 20 * Math.log10(outData[i] / peak + 1e-12);
        outData[i] = clamp((db - minDb) / spanDb, 0, 1);
      }

      return {
        data: outData,
        frames,
        bins,
        hopSize,
        sampleRate,
        duration: audioBuffer.duration,
        totalDuration: audioBuffer.duration,
        sliceStart: start,
        sliceDuration: duration,
        viewStart: start,
        viewDuration: duration
      };
    }

    async function computeSpectrogramAuto(opts) {
      // try GPU first
      if (preferWebGPU) {
        try {
          const gpuSpec = await computeSpectrogramWebGPU(opts);
          if (gpuSpec) return gpuSpec;
        } catch (e) {
          console.warn('WebGPU spectrogram failed, fallback to CPU', e);
        }
      }
      return computeSpectrogramCPU(opts);
    }

    async function buildHiResSpectrogram(viewStart, viewDuration, ppsCss) {
      if (chkEnableSpec && !chkEnableSpec.checked) return;
      if (!audioBufferSrc || !ppsCss || !(viewDuration > 0)) return;
      if (hiResPending) return;
      const hopTarget = Math.max(32, Math.min(4096, floorPow2(audioSampleRate / ppsCss)));
      if (hiResMatches(viewStart, viewDuration, hopTarget)) return;
      const token = ++hiResRequestId;
      hiResPending = true;
      lastHiResRequestedAt = performance.now ? performance.now() : Date.now();
      try {
        const spec = await computeSpectrogramAuto({
          audioBuffer: audioBufferSrc,
          start: viewStart,
          duration: viewDuration,
          hopSize: hopTarget,
          fftSize: 1024
        });
        if (token !== hiResRequestId) return;
        hiResSpec = spec;
        const v = getSpecView();
        drawSpectrogram(v.viewStart, v.viewDuration);
      } catch (e) {
        console.warn('hi-res spectrogram failed', e);
      } finally {
        hiResPending = false;
      }
    }

    function drawSpectrogram(viewStart, viewDuration) {
      if (!spectrumCanvas) return;
      resizeSpectrumCanvas();
      const ctx = spectrumCanvas.getContext('2d');
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const cssWidth = spectrumContainer.getBoundingClientRect().width || 1;
      const width = spectrumCanvas.width;
      const height = spectrumCanvas.height;
      ctx.clearRect(0, 0, width, height);

      if (!spectrogram || !spectrogram.data || spectrogram.frames === 0 || spectrogram.bins === 0) {
        return;
      }

      const ppsCss = currentPixelsPerSecond();
      if (!ppsCss) return;

      if (shouldUseHiRes(ppsCss)) {
        maybeRequestHiRes(viewStart, viewDuration, ppsCss);
      }

      // Choose base (full-length) spec or hi-res slice based on zoom density
      const useHiRes = shouldUseHiRes(ppsCss) && hiResMatches(viewStart, viewDuration, Math.max(32, Math.min(4096, floorPow2(audioSampleRate / ppsCss))));
      const spec = useHiRes && hiResSpec ? hiResSpec : spectrogram;
      const { data, frames, bins, hopSize, sampleRate, duration, sliceStart = 0, sliceDuration = duration, totalDuration = duration } = spec;
      const image = ctx.createImageData(width, height);
      const dest = image.data;
      const timePerFrame = hopSize / sampleRate;

      let vs = Number.isFinite(viewStart) ? viewStart : 0;
      let vd = Number.isFinite(viewDuration) && viewDuration > 0 ? viewDuration : totalDuration;
      vd = Math.min(vd, totalDuration);
      vs = clamp(vs, 0, Math.max(0, totalDuration - vd));
      specViewStart = vs;
      specViewDuration = vd;

      const ppsCssEff = ppsCss || (cssWidth / Math.max(1e-6, vd));
      const ppsDev = ppsCssEff * dpr;

      // How many device pixels we will actually draw (can be narrower than canvas)
      const drawWidth = Math.min(width, Math.round(vd * ppsDev));

      const binScale = bins > 1 ? (bins - 1) / Math.max(1, height - 1) : 0;

      for (let x = 0; x < drawWidth; x++) {
        const t = vs + x / ppsDev;
        const frameIdx = clamp(Math.round((t - sliceStart) / timePerFrame), 0, frames - 1);
        const frameBase = frameIdx * bins;
        for (let y = 0; y < height; y++) {
          const bin = bins - 1 - Math.min(bins - 1, Math.round(y * binScale));
          const v = data[frameBase + bin] || 0;
          const lut = HEAT_LUT[Math.min(255, Math.max(0, Math.floor(v * 255)))];
          const p = (y * width + x) * 4;
          dest[p] = lut[0];
          dest[p + 1] = lut[1];
          dest[p + 2] = lut[2];
          dest[p + 3] = 255;
        }
      }

      ctx.putImageData(image, 0, 0);
    }

    function updateSpecPlayhead(forceHide = false) {
      if (!specPlayhead) return;
      if (forceHide || !spectrogram || !Number.isFinite(audio.duration) || audio.duration <= 0) {
        specPlayhead.style.display = 'none';
        return;
      }
      const rect = spectrumContainer.getBoundingClientRect();
      const ppsCss = currentPixelsPerSecond();
      if (!ppsCss) {
        specPlayhead.style.display = 'none';
        return;
      }
      const maxX = Math.min(rect.width, (specViewDuration || audio.duration) * ppsCss);
      const x = clamp((audio.currentTime - specViewStart) * ppsCss, 0, maxX);
      const phw = (specPlayhead.offsetWidth || 1);
      const xAligned = clamp(x - phw * 0.5, 0, Math.max(0, maxX - phw));
      specPlayhead.style.display = 'block';
      specPlayhead.style.transform = `translateX(${xAligned}px)`;
    }

    function maybeRedrawSpecOnViewChange() {
      const view = getSpecView();
      if (!view) return;
      const eps = Math.max(1e-4, (view.viewDuration || 1) * 1e-3); // ~0.1% of window
      if (Math.abs(view.viewStart - specViewStart) > eps || Math.abs(view.viewDuration - specViewDuration) > eps) {
        drawSpectrogram(view.viewStart, view.viewDuration);
      }
    }

    const yieldFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));

    function buildHann(fftSize) {
      const hann = new Float32Array(fftSize);
      for (let i = 0; i < fftSize; i++) hann[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (fftSize - 1)));
      return hann;
    }

    async function computeSpectrogramCPU({ audioBuffer, start = 0, duration = audioBuffer.duration, hopSize, fftSize = 1024 }) {
      const sampleRate = audioBuffer.sampleRate;
      const channelCount = audioBuffer.numberOfChannels;
      const startSample = Math.max(0, Math.floor(start * sampleRate));
      const endSample = Math.min(audioBuffer.length, Math.ceil((start + duration) * sampleRate));
      const segmentLen = Math.max(0, endSample - startSample);

      const mono = new Float32Array(segmentLen);
      for (let ch = 0; ch < channelCount; ch++) {
        const src = audioBuffer.getChannelData(ch);
        for (let i = 0; i < segmentLen; i++) mono[i] += src[startSample + i];
      }
      const invCh = 1 / Math.max(1, channelCount);
      for (let i = 0; i < segmentLen; i++) mono[i] *= invCh;

      const bins = fftSize / 2;
      const frames = Math.max(1, Math.floor((segmentLen - fftSize) / hopSize) + 1);
      const hann = buildHann(fftSize);
      const fft = createFFT(fftSize);
      const re = new Float32Array(fftSize);
      const im = new Float32Array(fftSize);
      const data = new Float32Array(frames * bins);

      let peak = 1e-9;
      for (let frame = 0; frame < frames; frame++) {
        const offset = frame * hopSize;
        for (let i = 0; i < fftSize; i++) {
          const idx = offset + i;
          re[i] = (idx < mono.length ? mono[idx] : 0) * hann[i];
          im[i] = 0;
        }
        fft.transform(re, im);
        const base = frame * bins;
        for (let b = 0; b < bins; b++) {
          const mag = Math.hypot(re[b], im[b]);
          data[base + b] = mag;
          if (mag > peak) peak = mag;
        }
        if (frame % 500 === 0) await yieldFrame();
      }

      const minDb = -85;
      const spanDb = -minDb;
      for (let i = 0; i < data.length; i++) {
        const mag = data[i];
        const db = 20 * Math.log10(mag / peak + 1e-12);
        data[i] = clamp((db - minDb) / spanDb, 0, 1);
        if (i % 131072 === 0) await yieldFrame();
      }

      const sliceDuration = duration;
      return {
        data,
        frames,
        bins,
        sampleRate,
        hopSize,
        duration: audioBuffer.duration,
        totalDuration: audioBuffer.duration,
        sliceStart: start,
        sliceDuration
      };
    }

    async function buildSpectrogram(audioBuffer) {
      const token = ++spectrogramRequestId;
      if (chkEnableSpec && !chkEnableSpec.checked) {
        setSpectrumStatus('（スペクトログラム計算オフ）');
        return;
      }
      setSpectrumStatus('スペクトログラム解析中…');
      spectrogram = null;
      hiResSpec = null;
      clearSpectrumCanvas();

      let spec = null;
      try {
        spec = await computeSpectrogramAuto({
          audioBuffer,
          start: 0,
          duration: audioBuffer.duration,
          hopSize: Math.max(256, Math.floor(audioBuffer.sampleRate * 0.02)),
          fftSize: 1024
        });
      } catch (e) {
        console.error('Failed to compute spectrogram:', e);
      }
      if (token !== spectrogramRequestId) return;
      spectrogram = spec;
      setSpectrumStatus(spec ? '' : 'スペクトログラム作成に失敗しました');
      const view = getSpecView();
      drawSpectrogram(view.viewStart, view.viewDuration);
      updateSpecPlayhead();
    }

    // 共通：双対数スライダー（中央が1x、左右に min/max）
    function createBiLogMapping({ min, max, steps }) {
      return { min, max, steps, mid: steps / 2 };
    }

    function factorFromSlider(value, map) {
      const v = clamp(Number(value), 0, map.steps);
      const mid = map.mid;
      if (v === mid) return 1;
      if (v < mid) {
        const p = v / mid; // 0..1
        return map.min * Math.pow(1 / map.min, p);
      }
      const p = (v - mid) / mid; // 0..1
      return Math.pow(map.max, p);
    }

    function sliderFromFactor(factor, map) {
      const f = clamp(factor, map.min, map.max);
      const mid = map.mid;
      if (Math.abs(f - 1) < 1e-12) return Math.round(mid);
      if (f < 1) {
        const p = Math.log(f / map.min) / Math.log(1 / map.min); // 0..1
        return Math.round(p * mid);
      }
      const p = Math.log(f) / Math.log(map.max); // 0..1
      return Math.round(mid + p * mid);
    }

    const SNAP_RANGE = 0.1; // ±10% で 1x にスナップ

    // ズーム設定
    const BASE_SPP_1X = 2048;      // 1x に相当する samplesPerPixel
    const zoomMap = createBiLogMapping({ min: 0.125, max: 256, steps: 200 });

    // 再生速度設定（元の1/16～16x を連続化）
    const rateMap = createBiLogMapping({ min: 0.0625, max: 16, steps: 200 });

    function factorToSamplesPerPixel(factor) { return BASE_SPP_1X / factor; }

    function buildZoomLevels(map) {
      const levels = [];
      for (let i = 0; i <= map.steps; i++) {
        const f = factorFromSlider(i, map);
        levels.push(Math.round(factorToSamplesPerPixel(f)));
      }
      // Peaks.js は昇順の samplesPerPixel 配列を期待するので uniq + sort
      return Array.from(new Set(levels)).sort((a, b) => a - b);
    }

    let zoomLevels = buildZoomLevels(zoomMap); // Peaks.js に渡す昇順リスト

    function findClosestZoomIndex(samplesPerPixel) {
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < zoomLevels.length; i++) {
        const diff = Math.abs(zoomLevels[i] - samplesPerPixel);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    function currentSliderFactor(elInput, map) {
      const raw = Number(elInput.value) || 0;
      const f = factorFromSlider(raw, map);
      return Math.abs(f - 1) <= SNAP_RANGE ? 1 : f;
    }

    function currentSamplesPerPixel() {
      const target = factorToSamplesPerPixel(currentSliderFactor(elZoom, zoomMap));
      const idx = findClosestZoomIndex(target);
      return zoomLevels[idx] ?? target;
    }

    function formatFactor(factor) {
      if (factor >= 10) return factor.toFixed(0);
      if (factor >= 1) return factor.toFixed(2);
      if (factor >= 0.1) return factor.toFixed(3);
      return factor.toFixed(4);
    }

    function setFactorLabel(labelEl, factor, snapped) {
      if (snapped || Math.abs(factor - 1) < 1e-6) {
        labelEl.textContent = '1.0x';
        labelEl.style.color = '#ffd166';
      } else {
        labelEl.textContent = `${formatFactor(factor)}x`;
        labelEl.style.color = 'var(--muted)';
      }
    }

    // 共通: ラベルをクリックして倍率を直接入力
    function makeInlineFactorEditable(labelEl, { map, getCurrent, applyFactor }) {
      if (!labelEl) return;
      labelEl.style.cursor = 'pointer';
      labelEl.title = 'クリックして値を入力 (Enterで確定 / Escでキャンセル)';

      labelEl.addEventListener('click', () => {
        if (labelEl.dataset.skipClick === '1') { labelEl.dataset.skipClick = '0'; return; }
        if (labelEl.dataset.editing === '1') return;
        labelEl.dataset.editing = '1';

        const parent = labelEl.parentNode;
        if (!parent) {
          labelEl.dataset.editing = '0';
          return;
        }

        const current = Number(getCurrent?.()) || 1;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = formatFactor(current);
        const w = Math.max(labelEl.getBoundingClientRect().width || 0, 56);
        input.style.width = `${w}px`;
        input.style.fontSize = '11px';
        input.style.padding = '4px 6px';
        input.style.borderRadius = '8px';
        input.style.border = '1px solid rgba(255,255,255,.25)';
        input.style.background = '#0a0f1b';
        input.style.color = 'var(--text)';
        input.style.textAlign = 'center';
        input.style.boxSizing = 'border-box';

        parent.replaceChild(input, labelEl);

        const restore = () => {
          if (input.parentNode === parent) parent.replaceChild(labelEl, input);
          labelEl.dataset.editing = '0';
        };

        const commit = () => {
          const v = parseFloat(normalizeNumberLikeText(input.value));
          if (Number.isFinite(v)) {
            const clamped = clamp(v, map.min, map.max);
            if (typeof applyFactor === 'function') applyFactor(clamped);
          }
          restore();
        };

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commit(); }
          if (e.key === 'Escape') { e.preventDefault(); restore(); }
        });
        input.addEventListener('blur', commit);

        setTimeout(() => {
          input.focus();
          input.setSelectionRange(0, input.value.length);
        }, 0);
      });
    }

    function bindBiLogSlider({ inputEl, labelEl, map, onChange }) {
      inputEl.min = '0';
      inputEl.max = String(map.steps);

      const applyFromSlider = (rawVal) => {
        const clamped = clamp(Math.round(Number(rawVal) || 0), 0, map.steps);
        let factor = factorFromSlider(clamped, map);
        let snapped = false;
        if (Math.abs(factor - 1) <= SNAP_RANGE) {
          factor = 1;
          const snapVal = sliderFromFactor(1, map);
          if (snapVal !== clamped) inputEl.value = String(snapVal);
          snapped = true;
        }
        setFactorLabel(labelEl, factor, snapped);
        if (typeof onChange === 'function') onChange(factor, snapped);
      };

      inputEl.addEventListener('input', () => applyFromSlider(inputEl.value));

      const set = (factor) => {
        const sliderVal = sliderFromFactor(factor, map);
        inputEl.value = String(sliderVal);
        applyFromSlider(sliderVal);
      };

      return { set };
    }

    function applyZoom(factor, optionalStartTime) {
      if (!peaksInstance) return;
      const spp = Math.round(factorToSamplesPerPixel(factor));
      const idx = findClosestZoomIndex(spp);
      try {
        if (optionalStartTime !== undefined) {
          peaksInstance.zoom.setZoom(idx, optionalStartTime);
        } else {
          peaksInstance.zoom.setZoom(idx);
        }
        const view = getSpecView();
        drawSpectrogram(view.viewStart, view.viewDuration);
        updateSpecPlayhead();
      } catch (e) {
        console.warn('zoom.setZoom failed:', e);
      }
    }

    function applyRate(factor) {
      const r = clamp(factor, rateMap.min, rateMap.max);
      audio.playbackRate = r;
      try {
        if (peaksInstance && peaksInstance.player && typeof peaksInstance.player.setPlaybackRate === 'function') {
          peaksInstance.player.setPlaybackRate(r);
        }
      } catch (e) {
        console.warn('Failed to sync playbackRate to Peaks:', e);
      }
    }

    const rateSlider = bindBiLogSlider({
      inputEl: selRate,
      labelEl: elRateLabel,
      map: rateMap,
      onChange: (factor) => applyRate(factor)
    });

    const zoomSlider = bindBiLogSlider({
      inputEl: elZoom,
      labelEl: elZoomLabel,
      map: zoomMap,
      onChange: (factor) => {
        if (!peaksInstance) return;
        applyZoom(factor);
      }
    });

    // クリックで直接入力できるようにする
    makeInlineFactorEditable(elRateLabel, {
      map: rateMap,
      getCurrent: () => currentSliderFactor(selRate, rateMap),
      applyFactor: (f) => rateSlider.set(f)
    });

    makeInlineFactorEditable(elZoomLabel, {
      map: zoomMap,
      getCurrent: () => currentSliderFactor(elZoom, zoomMap),
      applyFactor: (f) => zoomSlider.set(f)
    });

    attachDragNudge(elRateLabel, {
      getValue: () => currentSliderFactor(selRate, rateMap),
      applyValue: (v, isFinal) => {
        rateSlider.set(v);
        if (isFinal) setFactorLabel(elRateLabel, v, Math.abs(v - 1) < 1e-6);
      },
      min: rateMap.min,
      max: rateMap.max,
      compute: (dx, start) => clamp(start * Math.exp(dx * 0.01), rateMap.min, rateMap.max)
    });

    attachDragNudge(elZoomLabel, {
      getValue: () => currentSliderFactor(elZoom, zoomMap),
      applyValue: (v, isFinal) => {
        zoomSlider.set(v);
        if (isFinal) setFactorLabel(elZoomLabel, v, Math.abs(v - 1) < 1e-6);
      },
      min: zoomMap.min,
      max: zoomMap.max,
      compute: (dx, start) => clamp(start * Math.exp(dx * 0.01), zoomMap.min, zoomMap.max)
    });

    async function initWithFile(file) {
      destroyPeaks();
      keyframes = [];
      allLabels = [];
      kfSeq = 1;
      renderKeyframeList();
      updateJson();

      if (objectUrl) URL.revokeObjectURL(objectUrl);
      objectUrl = URL.createObjectURL(file);
      audio.src = objectUrl;

      // decode for Peaks.js webAudio.audioBuffer
      const arrayBuffer = await file.arrayBuffer();
      const ctx = ensureAudioContext();
      const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
      audioBufferSrc = audioBuffer;
      audioSampleRate = audioBuffer.sampleRate;

      const options = {
        overview: {
          container: overviewContainer,
          waveformColor: 'rgba(225,232,240,0.92)',       // 少し明るい灰色
          playedWaveformColor: 'rgba(245,248,255,0.95)', // 再生済みはさらに明るく
          playheadColor: '#ffd166',
          highlightColor: 'rgba(255,209,102,0.80)',      // 窓の塗りを暖色で強調（高不透明度）
          highlightStrokeColor: 'rgba(255,209,102,0.95)', // 枠線を鮮やかに
          highlightStrokeWidth: 2
        },
        zoomview: {
          container: zoomviewContainer,
          playheadColor: '#ffd166',
          playheadTextColor: '#0b0f17',
          playheadClickTolerance: 10,
          showPlayheadTime: true
        },
        mediaElement: audio,
        webAudio: { audioBuffer },
        zoomLevels,
        keyboard: false  // 独自のキーボードショートカットを使用
      };

      await new Promise((resolve, reject) => {
        window.peaks.init(options, (err, peaks) => {
          if (err) return reject(err);
          peaksInstance = peaks;
          resolve();
        });
      });

      buildSpectrogram(audioBuffer);

      updateTimeBadge();

      // 初期ズーム：1x にスナップした状態から開始
      zoomSlider.set(1);

      setUiEnabled(true);
      audio.pause();
      audio.currentTime = 0;
      rateSlider.set(1);
      updateTimeBadge();
      try { fileInput.blur(); } catch (_) {}
    }

    function addKeyframe() {
      if (!peaksInstance) return;

      const time = audio.currentTime;
      const id = `kf-${kfSeq++}`;
      const seq = kfSeq - 1;
      const initLabel = lastEditedLabel || '';

      // 波形上にポイントを追加（time / labelText 等）
      let pointId = null;
      try {
        const p = peaksInstance.points.add({
          time,
          labelText: id,
          editable: false,
          color: '#888888'  // デフォルト色（ラベルなし）
        });
        pointId = p && p.id ? p.id : null;
      } catch (e) {
        console.warn('points.add failed:', e);
      }

      keyframes.push({ id, seq, time, label: initLabel, comment: '', pointId });

      if (initLabel) lastEditedLabel = initLabel;
      renderKeyframeList();
      updateJson();
    }

    // UI wiring
    fileInput.addEventListener('change', async () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;
      await loadFile(file);
    });

    function updatePlayButton() {
      if (!btnPlay) return;
      const playing = !audio.paused;
      btnPlay.textContent = playing ? '⏸' : '▶';
      btnPlay.title = playing ? '停止 (Space)' : '再生 (Space)';
    }

    btnPlay.addEventListener('click', () => {
      if (audio.paused) {
        audio.play();
      } else {
        audio.pause();
      }
      updatePlayButton();
    });

    function stopStepPreview() {
      if (stepPreviewTimer) {
        clearTimeout(stepPreviewTimer);
        stepPreviewTimer = null;
      }
      isStepPreview = false;
    }

    function step(delta) {
      const wasPlaying = !audio.paused;
      const next = clamp(audio.currentTime + delta, 0, (audio.duration || Infinity));
      stopStepPreview();
      audio.currentTime = next;
      audio.pause();
      updateTimeBadge();
      updateSpecPlayhead();

      if (wasPlaying) return; // 再生中はそのまま流す

      const previewMs = FRAME_SEC * 1000;
      isStepPreview = true;
      audio.play().catch(() => { isStepPreview = false; });
      stepPreviewTimer = setTimeout(() => {
        stepPreviewTimer = null;
        audio.pause();
        audio.currentTime = next; // ensure position stays at target
        isStepPreview = false;
      }, previewMs);
    }

    btnStepBack.addEventListener('click', () => step(-FRAME_SEC));
    btnStepFwd.addEventListener('click', () => step(+FRAME_SEC));

    btnAddKf.addEventListener('click', addKeyframe);

    audio.addEventListener('timeupdate', () => {
      updateTimeBadge();
    });

    btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(jsonArea.value);
        btnCopy.textContent = 'コピーしました';
        setTimeout(() => (btnCopy.textContent = 'コピー'), 900);
      } catch (e) {
        alert('クリップボードへのコピーに失敗しました。HTTPS or localhost が必要な場合があります。');
      }
    });

    if (jsonArea) {
      const scheduleJsonApply = () => {
        if (jsonApplyTimer) clearTimeout(jsonApplyTimer);
        jsonApplyTimer = setTimeout(() => {
          jsonApplyTimer = null;
          applyJsonToState();
        }, JSON_APPLY_DEBOUNCE_MS);
      };
      jsonArea.addEventListener('input', () => {
        if (isUpdatingJsonArea) return;
        scheduleJsonApply();
      });
      jsonArea.addEventListener('blur', () => {
        if (isUpdatingJsonArea) return;
        if (jsonApplyTimer) {
          clearTimeout(jsonApplyTimer);
          jsonApplyTimer = null;
        }
        applyJsonToState();
      });
    }

    // Time display click-to-edit (custom modal)
    if (timeBadge) {
      timeBadge.addEventListener('click', () => {
        if (timeBadge.dataset.skipClick === '1') { timeBadge.dataset.skipClick = '0'; return; }
        startInlineTimeEdit();
      });

      attachDragNudge(timeBadge, {
        getValue: () => audio.currentTime || 0,
        applyValue: (v) => {
          const dur = Number.isFinite(audio.duration) ? audio.duration : Infinity;
          audio.currentTime = clamp(v, 0, dur);
          updateTimeBadge();
          updateSpecPlayhead();
          maybeRedrawSpecOnViewChange();
        },
        min: 0,
        max: () => Number.isFinite(audio.duration) ? audio.duration : Infinity,
        stepPerPx: 0.01
      });
    }

    // Spectrogram enable toggle
    if (chkEnableSpec) {
      chkEnableSpec.addEventListener('change', () => {
        if (!chkEnableSpec.checked) {
          rememberedWebGpu = chkWebGPU ? chkWebGPU.checked : rememberedWebGpu;
          if (chkWebGPU) {
            chkWebGPU.disabled = true;
            chkWebGPU.checked = false;
          }
          teardownSpectrum();
        } else if (audioBufferSrc) {
          if (chkWebGPU) {
            chkWebGPU.disabled = false;
            chkWebGPU.checked = rememberedWebGpu && webgpuSupported;
            preferWebGPU = chkWebGPU.checked;
          }
          buildSpectrogram(audioBufferSrc);
        } else {
          if (chkWebGPU) {
            chkWebGPU.disabled = false;
            chkWebGPU.checked = rememberedWebGpu && webgpuSupported;
            preferWebGPU = chkWebGPU.checked;
          }
        }
      });
      // initial state
      if (!chkEnableSpec.checked && chkWebGPU) {
        rememberedWebGpu = chkWebGPU.checked;
        chkWebGPU.disabled = true;
        chkWebGPU.checked = false;
      }
    }

    // Drag & drop for audio
    if (dropZone) {
      const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
      ['dragenter','dragover'].forEach(ev => {
        dropZone.addEventListener(ev, (e) => { prevent(e); dropZone.classList.add('hover'); });
      });
      ['dragleave','drop'].forEach(ev => {
        dropZone.addEventListener(ev, (e) => { prevent(e); dropZone.classList.remove('hover'); });
      });
      dropZone.addEventListener('drop', async (e) => {
        const files = e.dataTransfer?.files;
        if (!files || files.length === 0) return;
        const file = Array.from(files).find(isAudioFile) || files[0];
        if (file) {
          await loadFile(file);
        } else {
          alert('音声ファイルをドロップしてください (mp3 / wav / ogg など)');
        }
      });
      // Prevent browser from opening file when dropped outside
      ['dragover','drop'].forEach(ev => document.addEventListener(ev, prevent));
    }

    // WebGPU toggle
    if (chkWebGPU) {
      chkWebGPU.checked = preferWebGPU;
      if (!webgpuSupported) {
        chkWebGPU.disabled = true;
        chkWebGPU.title = 'このブラウザは WebGPU に未対応です';
      }
      chkWebGPU.addEventListener('change', () => {
        preferWebGPU = chkWebGPU.checked && webgpuSupported;
        hiResSpec = null;
        hiResRequestId++;
        spectrogramRequestId++;
        if (audioBufferSrc) {
          buildSpectrogram(audioBufferSrc);
        } else {
          setSpectrumStatus('ファイル未選択');
        }
      });
    }

    if (labelFilter) {
      labelFilter.addEventListener('change', () => {
        filterLabel = labelFilter.value || '';
        renderKeyframeList();
      });
    }

    // beforeunload guard when keyframes exist
    window.addEventListener('beforeunload', (e) => {
      if (keyframes.length > 0) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    function startSpecSync() {
      if (specSyncRaf) return;
      const tick = () => {
        updateTimeBadge();
        updateSpecPlayhead();
        maybeRedrawSpecOnViewChange();
        specSyncRaf = requestAnimationFrame(tick);
      };
      specSyncRaf = requestAnimationFrame(tick);
    }

    function stopSpecSync() {
      if (specSyncRaf) cancelAnimationFrame(specSyncRaf);
      specSyncRaf = null;
    }

    function startScrubSpecSync() {
      if (specScrubRaf) return;
      const loop = () => {
        maybeRedrawSpecOnViewChange();
        updateSpecPlayhead();
        if (isScrubbingZoomview) {
          specScrubRaf = requestAnimationFrame(loop);
        } else {
          specScrubRaf = null;
        }
      };
      specScrubRaf = requestAnimationFrame(loop);
    }

    function stopScrubSpecSync() {
      if (specScrubRaf) cancelAnimationFrame(specScrubRaf);
      specScrubRaf = null;
      maybeRedrawSpecOnViewChange();
      updateSpecPlayhead();
    }

    audio.addEventListener('play', () => {
      if (!isStepPreview) stopStepPreview();
      startSpecSync();
      updatePlayButton();
    });
    audio.addEventListener('pause', () => {
      stopSpecSync();
      if (isStepPreview) stopStepPreview();
      updatePlayButton();
    });
    audio.addEventListener('ended', stopSpecSync);

      bindScrubHandlers();
      window.addEventListener('resize', () => {
        const view = getSpecView();
        drawSpectrogram(view.viewStart, view.viewDuration);
        updateSpecPlayhead();
      });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (btnPlay.disabled) return;

      // テキスト入力中はショートカットを抑制。ズームの range では Space だけ通す。
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      const type = (e.target && e.target.type) ? e.target.type.toLowerCase() : '';
      const isRange = tag === 'input' && type === 'range';
      const isTextEntry = (tag === 'input' && type !== 'range') || tag === 'textarea';
      if (isTextEntry && e.code !== 'Space' && !['k','h','l'].includes(e.key.toLowerCase())) return; // テキスト入力中は Space と h/l/k だけ通す

      if (e.code === 'Space') {
        e.preventDefault();
        if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
        return;
      }

      const mul = e.shiftKey ? 10 : 1;
      const key = e.key.toLowerCase();
      if (key === 'h') {
        e.preventDefault();
        step(-FRAME_SEC * mul);
        return;
      }
      if (key === 'l') {
        e.preventDefault();
        step(+FRAME_SEC * mul);
        return;
      }
      if (key === 'k') {
        e.preventDefault();
        addKeyframe();
        return;
      }
    });

    // 初期状態
    zoomSlider.set(1);
    rateSlider.set(1);
    setUiEnabled(false);
    updateJson();
    renderKeyframeList();
    const view = getSpecView();
    drawSpectrogram(view.viewStart, view.viewDuration);
  </script>
</body>
</html>
